options {
  IGNORE_CASE=true;
}

PARSER_BEGIN(simplejava)

public class simplejava {
}

PARSER_END(simplejava)

TOKEN_MGR_DECLS : 
{
	public static int nestedcomments = 0;
}

SKIP : 
{
  	< " " >
|   < "\\t">
|   < "\t">
|	< "EOF">
|	< "\n">
|	< "/*" > { nestedcomments++; SwitchTo(IN_COMMENT);}
|	< "//" (~["\n"])* "\n" >
}

<IN_COMMENT>
SKIP :
{
	< "*/" > { nestedcomments--; if (nestedcomments == 0) SwitchTo(DEFAULT);}
|	< "/*" > { nestedcomments++; }
|	< ~[] >
}

TOKEN : 
{
	< ELSE: "else">
|	< FOR: "for">
|	< IF: "if">
|	< WHILE: "while">
|	< DO: "do">
|	< CLASS: "class">
|	< TRUE: "true">
|	< FALSE: "false">
|	< RETURN: "return">
|	< NEW: "new">
}

TOKEN : 
{
	< PLUS: "+" >
|	< SEMICOLON: ";">
|	< MINUS: "-">
|	< TIMES: "*">
|	< DIVIDE: "/">
|	< EQUAL: "==">
|	< GREATER_THAN: ">">
|	< NOT: "!">
|	< LEFT_BRACE: "{">
|	< LEFT_BRACKET: "[">
|	< RIGHT_BRACKET: "]">
|	< PERIOD: ".">
|	< COMMA: ",">
|	< GREATER_THAN_OR_EQUAL_TO: ">=">
|	< AND: "&&">
|	< RIGHT_BRACE: "}">
|	< LEFT_PARENTHESIS: "(">
|	< RIGHT_PARENTHESIS: ")">
|	< NOT_EQUAL: "!=">
|	< LESS_THAN_OR_EQUAL_TO: "<=">
|	< LESS_THAN: "<">
|	< GETS: "=">
|	< OR: "||">
|	< ADD: "++">
|	< MINUSMINUS: "--">
|   < INTEGER_LITERAL: (["0"-"9"])+>
|	< IDENTIFIER: ["a"-"z"](["a"-"z","0"-"9"])*>

}

void incrementstatement() :
{}
{
	<ADD>
}

void decrementstatement() :
{}
{
	<MINUSMINUS>
}

void program() :
{}
{    
/*perhaps put a star there to check multiple statements */
	/* 1) 0 or more class defs	2) 0 or more function defs	3) EOF */
	((classdefinitions())*) ((functionprototypeordefinition())*) <EOF> 
//	expression() 
}



ASTFunctionDefinition functionprototypeordefinition() :
{Token type; Token name; ASTFormals formals = new ASTFormals(); ASTStatements body = new ASTStatements(); int line; ASTEmptyStatement semicolonchecker = null; ASTStatement returnedstatement = null;}
{
	
	type = <IDENTIFIER> name = <IDENTIFIER> <LEFT_PARENTHESIS> ((formals = formalparameterlist())?) <RIGHT_PARENTHESIS> (semicolonchecker = emptystatement() | <LEFT_BRACE> ((returnedstatement = statement() {body.addElement(returnedstatement);})*) )
	{if (semicolonchecker != null) {
		return new ASTPrototype(type.image, name.image, formals, type.beginLine);
	}else {
		return new ASTFunction(type.image, name.image, formals, body, type.beginLine);
	}}
}

void functionendingafterparen() :
{}
{
	/* FUNCTION PROTOTYPE */
	<SEMICOLON>
	/* FUNCTION DEFINITION */
|	<LEFT_BRACE> ((statement())*) <RIGHT_BRACE>
}

ASTFormals formalparameterlist() :
{ASTFormals formals = null; ASTFormal formal = null;}
{
	(formal = formalparameter()) {if (formal != null) {formals = new ASTFormals(formal);}}((<COMMA> formal = formalparameter())*) {if (formal != null) {formals.addElement(formal);}}
	{if (formals != null) {
		return formals;
	}}
}

ASTFormal formalparameter() :
{ASTFormal returnformal = null; Token type; Token name; boolean checker = false;}
{
	type = <IDENTIFIER> name = <IDENTIFIER> variabledeclarations()
	{if (checker == true) {
		returnformal = new ASTFormal(type.image, name.image, type.beginLine);
	}}
	{if (returnformal != null) {
		return returnformal;
	}}
}

int variabledeclarations() :
/* {Token onetok = null; Token twotok = null;} */
{int counter = 0;}
{	
	/*((onetok = <LEFT_BRACKET>) (twotok = <RIGHT_BRACKET>))* */
	(((<LEFT_BRACKET>) (<RIGHT_BRACKET>)) {counter++;})* 
	/* {if (onetok != null && twotok != null) {return true;} else {return false;}} */
	{return counter;}
}

void variabledefinitions() :
{}
{
	((<IDENTIFIER> <IDENTIFIER> (variabledeclarations())<SEMICOLON>)*)
}

void expressionlist() :
{}
{
	expression()((<COMMA>expression())*)
}

void statementlist() :
{}
{
	statement()((statement())*)
}

ASTVariable variable(ASTVariable passedinvar) :
{ASTVariable var = null;}
{
	((var = followsvariables(passedinvar))?)
	{return var;}
	
}

void followsclassdefinitionstypes() :
{}
{
/* HAVE  TO CONSIDER THI CASE EVENTUALLY */
	<LEFT_BRACKET> ((followsbracketsone())+) 

}

void classdefinitions() :
{}
{
	/* Get value of identifier so that identifier will not show up in the body */
	<CLASS> <IDENTIFIER> <LEFT_BRACE> variabledefinitions() <RIGHT_BRACE>
}

ASTStatement statement() :
/* POSSIBLE PROBLEMS WITH INTIALIZING ARRAYVARIABLETOKEN TO BE NULL */
{ASTAssignmentStatement assignstate; ASTVariable avariable = null; Token arrayvariabletoken = null; ASTExpression expression = null; int bracketcounter= 0; Token generaltoken; ASTVariable passedinvariable; ASTStatements returner = new ASTStatements();
ASTVariable bvariable = null;}
{
	dowhilestatement()
|	<RETURN> expression() <SEMICOLON>
|	<WHILE> <LEFT_PARENTHESIS> test() <RIGHT_PARENTHESIS> statement()
|	<IF> ifstatement()
|	forstatement()
|	<LEFT_BRACE> ((statement())*) <RIGHT_BRACE>
|	generaltoken = <IDENTIFIER> {passedinvariable = new ASTBaseVariable(generaltoken.image, generaltoken.beginLine);} ((arrayvariabletoken= <IDENTIFIER>  bracketcounter = variabledeclarations() {avariable = new ASTBaseVariable(arrayvariabletoken.image, arrayvariabletoken.beginLine);})| (bvariable = variable(
/* MAKE SURE TO MAKE CHANGES, was semicolon before but now is emptystatement because they mean the same thing */
passedinvariable))) ((expression = followsvariablenames())?) emptystatement() {if (bracketcounter == 0 && bvariable == null && expression == null) {
	return new ASTVariableDefStatement(generaltoken.image, arrayvariabletoken.image, generaltoken.beginLine);
} if (bracketcounter == 0 && bvariable == null && expression != null) {
	return new ASTVariableDefStatement(generaltoken.image, arrayvariabletoken.image, expression,generaltoken.beginLine);
}
if (bracketcounter != 0 && bvariable == null && expression == null) {

	return new ASTVariableDefStatement(generaltoken.image, arrayvariabletoken.image, bracketcounter,generaltoken.beginLine);
}
if (expression == null) {return null;} else {return new ASTAssignmentStatement(avariable, expression, arrayvariabletoken.beginLine);} }
|	emptystatement()
}

void test() :
{}
{
/*	booleanexpression()
|	<IDENTIFIER> ((expressionsversionfollowsvariablenames())?) */
expression()
}

void ifstatement() :
{}
{
	<LEFT_PARENTHESIS> expression() (((<AND> expression())?) | ((<OR> expression())?)) <RIGHT_PARENTHESIS> statement() ((LOOKAHEAD(1) <ELSE> statement())?) 
}

ASTEmptyStatement emptystatement() :
{Token semicolontoken; ASTEmptyStatement returnstate;}
{
	semicolontoken = <SEMICOLON>
	{returnstate = new ASTEmptyStatement(semicolontoken.beginLine);}
	{return returnstate;}
}

void dowhilestatement() :
{}
{
	<DO> statement() <WHILE> <LEFT_PARENTHESIS> expression() (((<AND> expression())?) | ((<OR> expression())?)) <RIGHT_PARENTHESIS> 
}

void initialization() :
{}
{
	incrementstatement()
|	decrementstatement()
|	assignmentstatement()
}

void forstatement() :
{}
{
	/*Second initialization() is actually increment from book */
	<FOR> <LEFT_PARENTHESIS> 
		((<IDENTIFIER> (followsvariablenames())*)?) <SEMICOLON> 
		test() <SEMICOLON> 
		((<IDENTIFIER> initialization())?) 
		<RIGHT_PARENTHESIS> statement()
}

ASTExpression expression() :
{Token t;ASTExpression result; ASTExpression rhs;}
{
	result = expone()((((t = <OR>) rhs =expone())
	{
		result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
	})*)
	{ return result; }
}

ASTExpression expone() :
{Token t; ASTExpression result; ASTExpression rhs; }
{
	result = exptwo()((((t= <AND>) rhs = exptwo())
	{
		result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
	}
	)*)
	{ return result;}
}

ASTExpression exptwo() :
{Token t; ASTExpression result; ASTExpression rhs;}
{
	result = expthree()((((t=<NOT>) rhs = expthree())
	{
		result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
	})*)
	{ return result;}
}

ASTExpression expthree() :
{Token t; ASTExpression result; ASTExpression rhs;}
{
	result = expfour()((((t=<EQUAL> | t=<NOT_EQUAL> | t=<LESS_THAN> | t=<LESS_THAN_OR_EQUAL_TO> | t=<GREATER_THAN> | t=<GREATER_THAN_OR_EQUAL_TO>) rhs = expfour())
		{
			result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
		}
		)*)
	{ return result;}	
}

ASTExpression expfour() :
{Token t; ASTExpression result; ASTExpression rhs;}
{
	result = expfive()((((t= <PLUS> | t= <MINUS>) rhs = expfive())
					{ 
						result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
					}
					)*)
	{ return result;}
}

ASTExpression expfive() :
{Token t; ASTExpression result; ASTExpression rhs;}
{
	result = F()((((t = <TIMES> | t= <DIVIDE>) rhs = F())
					{ 
					  result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
					}
					 )*)
	{ return result;}
}

ASTExpression F() :
{Token t; ASTExpression value = null;}
{
	<MINUS>value = F() {return new ASTOperatorExpression(new ASTIntegerLiteral(0, 0), value, ASTOperatorExpression.MINUS, 0);}
|	t = <INTEGER_LITERAL> { return new ASTIntegerLiteral(Integer.parseInt(t.image), t.beginLine);}
|	t = <TRUE> { return new ASTBooleanLiteral(Boolean.parseBoolean(t.image), t.beginLine);}
|	t = <FALSE> {return new ASTBooleanLiteral(Boolean.parseBoolean(t.image), t.beginLine);}
|	<IDENTIFIER> ((followsvariablenamesforexpressions())?)
|	<NEW> t = <IDENTIFIER> value = followsnewandidentifier(t) 
|	<LEFT_PARENTHESIS> value = expression()<RIGHT_PARENTHESIS>{return value;}
}

ASTExpression assignmentstatement() :
{ASTExpression value;}
{
	<GETS> value = expression() {return value;}

}

ASTExpression followsnewandidentifier(Token t) :
{int bracketcounter = 0;}
{
	<LEFT_BRACKET> (bracketcounter = followsbrackets())
|	<LEFT_PARENTHESIS><RIGHT_PARENTHESIS> {return new ASTNewClassExpression(t.image, t.beginLine);}
	{return null;}
}

void incrementstatements() :
{}
{
	incrementstatement()
|	decrementstatement()
}

ASTVariable followsvariables(ASTVariable astvar) :
{ASTArrayVariable arrayvar; ASTExpression express; ASTVariable nextvariable; Token variable;}
{
	((<PERIOD> variable = <IDENTIFIER> {nextvariable = new ASTBaseVariable(variable.image, variable.beginLine);})+) ((followsvariables(nextvariable))?) {return new ASTClassVariable(astvar, variable.image, variable.beginLine);}
	//TOKEN USED IN SECOND CASE JUST TO CAPTURE LINE NUMBER FOR NOW
|	((<LEFT_BRACKET> express = expression() variable = <RIGHT_BRACKET>)+) {astvar = null;} ((followsvariables(astvar))?) {return new ASTArrayVariable(astvar, express, variable.beginLine);}
}

ASTExpression followsvariablenames() :
{ASTExpression value;}
{
	/* How to prevent from class types from getting the same rules as variables*/
	/*<IDENTIFIER> ((followsvariablenames())*)*/ 
	<LEFT_PARENTHESIS> ((expressionlist())?) <RIGHT_PARENTHESIS> ((followsvariablenames())?)
|	value = assignmentstatement() {return value;} 
/* Need a way to make sure that amount of brackets are matched on left side with number on right side */
/*|	variabledeclarationstatemementsbrackets() ((followsvariablenames())?)*/
|	incrementstatements()
}

void followsvariablenamesforexpressions() :
{}
{
	/* How to prevent from class types from getting the same rules as variables*/
	<IDENTIFIER> ((followsvariablenamesforexpressions())*) 
|	((<PERIOD> <IDENTIFIER>)+) ((followsvariablenamesforexpressions())?)
|	<LEFT_PARENTHESIS> ((expressionlist())?) <RIGHT_PARENTHESIS> ((followsvariablenamesforexpressions())?)
/* Need a way to make sure that amount of brackets are matched on left side with number on right side */
/*|	variabledeclarationstatemementsbrackets() ((followsvariablenamesforexpressions())?)*/
|	((<LEFT_BRACKET> expression() <RIGHT_BRACKET>)+) ((followsvariablenamesforexpressions())?) 
|	incrementstatements()
}

void followsbracketsone() :
{}
{
	expression() <RIGHT_BRACKET> (((<LEFT_BRACKET><RIGHT_BRACKET>)))
}

ASTExpression followsbrackets() :
{int counter = 0; ASTExpression value = null;}
{
	value = expression() <RIGHT_BRACKET> {counter++;}(((<LEFT_BRACKET><RIGHT_BRACKET>){counter++;})*) {return new ASTNewArrayExpression(t.image, value, counter, t.beginLine);}
}